<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InvestFlow X | 獲利分析 v9.1 (日曆修復版)</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/prop-types@15.8.1/prop-types.min.js"></script>
    <script src="https://unpkg.com/recharts@2.10.3/umd/Recharts.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        xblack: '#000000',
                        xdark: '#16181c',
                        xgray: '#2f3336',
                        xlight: '#71767b',
                        xwhite: '#e7e9ea',
                        xaccent: '#1d9bf0',
                    },
                    fontFamily: {
                        sans: ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Microsoft JhengHei', 'sans-serif'],
                        mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'monospace'],
                    }
                }
            }
        }
    </script>
    <style>
        :root { color-scheme: light; }
        .dark { color-scheme: dark; } 
        body { transition: background-color 0.2s ease, color 0.2s ease; }
        .x-input {
            border-radius: 6px;
            transition: all 0.2s;
            position: relative;
            z-index: 50;
            font-family: inherit;
            background-color: #ffffff;
            border: 1px solid #cfd9de;
            color: #0f1419;
        }
        .dark .x-input {
            background-color: #202327 !important;
            border: 1px solid #333639;
            color: #ffffff !important;
        }
        .x-input:focus {
            border-color: #1d9bf0;
            outline: none;
            box-shadow: 0 0 0 2px rgba(29, 155, 240, 0.2);
        }
        .x-input::-webkit-calendar-picker-indicator {
            cursor: pointer;
            padding: 8px;
            margin-right: -4px;
            opacity: 1 !important; 
        }
        .x-input::-webkit-calendar-picker-indicator { filter: brightness(0); }
        .dark .x-input::-webkit-calendar-picker-indicator { filter: brightness(0) invert(1) !important; }
        .x-input::-webkit-calendar-picker-indicator:hover { background-color: rgba(128, 128, 128, 0.2); border-radius: 4px; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        .tradingview-widget-container { width: 100%; height: 46px; border-bottom: 1px solid #e5e7eb; overflow: hidden; }
        .dark .tradingview-widget-container { border-bottom: 1px solid #2f3336; }
    </style>
</head>
<body class="bg-white text-black dark:bg-black dark:text-xwhite">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;
        const RechartsLib = window.Recharts || {};
        const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, ComposedChart, Bar, Cell } = RechartsLib;

        const SUPABASE_URL = 'https://quugdrntvrmlndqgoshk.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF1dWdkcm50dnJtbG5kcWdvc2hrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjczMjkyMTksImV4cCI6MjA4MjkwNTIxOX0.WMMa-iju0V8JwY89EK0lAelNIBtw02OwcCVE2W5k6yM';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        const getTaiwanDateTime = () => {
            const now = new Date();
            const twDate = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Taipei' }));
            const y = twDate.getFullYear();
            const m = String(twDate.getMonth() + 1).padStart(2, '0');
            const d = String(twDate.getDate()).padStart(2, '0');
            const hh = String(twDate.getHours()).padStart(2, '0');
            const mm = String(twDate.getMinutes()).padStart(2, '0');
            return `${y}-${m}-${d}T${hh}:${mm}`;
        };

        const toLocalISOString = (dateStr) => {
            const date = new Date(dateStr);
            const offset = date.getTimezoneOffset() * 60000;
            const localDate = new Date(date.getTime() - offset);
            return localDate.toISOString().slice(0, 16);
        };

        const TickerTape = ({ isDarkMode }) => {
            const containerRef = useRef(null);
            useEffect(() => {
                if (containerRef.current) {
                    containerRef.current.innerHTML = '';
                    const script = document.createElement('script');
                    script.src = 'https://s3.tradingview.com/external-embedding/embed-widget-ticker-tape.js';
                    script.async = true;
                    script.innerHTML = JSON.stringify({
                        "symbols": [
                            { "proName": "BINANCE:BTCUSDT", "title": "Bitcoin" },
                            { "proName": "BINANCE:ETHUSDT", "title": "Ethereum" },
                            { "proName": "OANDA:XAUUSD", "description": "Gold" },
                            { "proName": "FOREXCOM:SPX500", "description": "S&P 500" },
                            { "proName": "FOREXCOM:NAS100", "description": "Nasdaq" },
                            { "proName": "FOREXCOM:DJI", "description": "Dow Jones" }
                        ],
                        "showSymbolLogo": true,
                        "colorTheme": isDarkMode ? "dark" : "light",
                        "isTransparent": true,
                        "displayMode": "adaptive",
                        "locale": "zh_TW"
                    });
                    containerRef.current.appendChild(script);
                }
            }, [isDarkMode]);
            return <div className="tradingview-widget-container" ref={containerRef}><div className="tradingview-widget-container__widget"></div></div>;
        };

        function App() {
            const [user, setUser] = useState(null);
            const [activeTab, setActiveTab] = useState('home');
            const [isDrawerOpen, setIsDrawerOpen] = useState(false);
            const [records, setRecords] = useState([]);
            const [initCap, setInitCap] = useState(0);
            const [filterRange, setFilterRange] = useState({ start: '', end: '' });
            const [activeTag, setActiveTag] = useState(null);
            
            // 日曆狀態
            const [calendarDate, setCalendarDate] = useState(new Date());

            const [isDarkMode, setIsDarkMode] = useState(() => {
                const savedTheme = localStorage.getItem('investflow_theme');
                if (savedTheme) return savedTheme === 'dark';
                return window.matchMedia('(prefers-color-scheme: dark)').matches;
            });

            useEffect(() => {
                const html = document.documentElement;
                if (isDarkMode) { html.classList.add('dark'); localStorage.setItem('investflow_theme', 'dark'); } 
                else { html.classList.remove('dark'); localStorage.setItem('investflow_theme', 'light'); }
            }, [isDarkMode]);
            
            const [assets, setAssets] = useState(() => {
                const saved = localStorage.getItem('investflow_assets');
                return saved ? JSON.parse(saved) : [
                    { id: 1, name: 'Binance (幣安)', amount: '' },
                    { id: 2, name: 'OKX (歐易)', amount: '' },
                    { id: 3, name: 'Cold Wallet (冷錢包)', amount: '' }
                ];
            });

            const [authForm, setAuthForm] = useState({ email: '', password: '' });
            const [mainForm, setMainForm] = useState({ amount: '', deposit: '', withdrawal: '', note: '', date: getTaiwanDateTime() });
            const [editingId, setEditingId] = useState(null);
            const [editForm, setEditForm] = useState({});

            useEffect(() => { localStorage.setItem('investflow_assets', JSON.stringify(assets)); }, [assets]);

            useEffect(() => {
                supabase.auth.getSession().then(({ data: { session } }) => {
                    setUser(session?.user ?? null);
                    if (session?.user) fetchUserSettings(session.user.id);
                });
                const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
                    setUser(session?.user ?? null);
                    if (session?.user) fetchUserSettings(session.user.id);
                });
                return () => subscription.unsubscribe();
            }, []);

            useEffect(() => { if (user) fetchData(); }, [user]);

            const fetchUserSettings = async (userId) => {
                const { data } = await supabase.from('user_settings').select('invest_init').eq('user_id', userId).single();
                if (data) setInitCap(data.invest_init);
            };

            const fetchData = async () => {
                const { data } = await supabase.from('records').select('*').order('date', { ascending: true });
                if (data) setRecords(data);
            };

            const handleAuth = async (e) => {
                e.preventDefault();
                const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({ email: authForm.email, password: authForm.password });
                if (signInError) {
                    const { error: signUpError } = await supabase.auth.signUp({ email: authForm.email, password: authForm.password });
                    if (signUpError) alert("驗證失敗: " + signUpError.message);
                    else alert("註冊成功，請嘗試登入");
                }
            };

            const syncInitCap = async (val) => {
                const numVal = parseFloat(val) || 0;
                setInitCap(numVal);
                if (user) await supabase.from('user_settings').upsert({ user_id: user.id, invest_init: numVal, updated_at: new Date().toISOString() });
            };

            const updateAsset = (id, field, value) => {
                setAssets(assets.map(a => a.id === id ? { ...a, [field]: value } : a));
            };

            const addAssetRow = () => {
                setAssets([...assets, { id: Date.now(), name: '', amount: '' }]);
            };

            const removeAssetRow = (id) => {
                if(assets.length > 1) {
                    setAssets(assets.filter(a => a.id !== id));
                } else {
                    setAssets([{ id: Date.now(), name: '', amount: '' }]);
                }
            };

            const totalAssets = useMemo(() => {
                return assets.reduce((sum, item) => sum + (parseFloat(item.amount) || 0), 0);
            }, [assets]);

            const handleSyncToLedger = async () => {
                if (totalAssets <= 0) return alert("總金額為 0，請先輸入資產金額。");
                if (!confirm(`確定要將總金額 $${totalAssets.toLocaleString()} 寫入帳本嗎？`)) return;
                const { error } = await supabase.from('records').insert([{
                    user_id: user.id,
                    date: new Date().toISOString(),
                    amount: parseFloat(totalAssets),
                    deposit: 0,
                    withdrawal: 0,
                    note: '來自資產清單同步'
                }]);
                if (!error) {
                    alert('✅ 已成功寫入帳本！');
                    fetchData();
                    setActiveTab('home'); 
                } else {
                    alert('寫入失敗: ' + error.message);
                }
            };

            const handleAdd = async (e) => {
                e.preventDefault();
                const { error } = await supabase.from('records').insert([{
                    user_id: user.id, 
                    date: new Date(mainForm.date).toISOString(),
                    amount: parseFloat(mainForm.amount), 
                    deposit: parseFloat(mainForm.deposit || 0),
                    withdrawal: parseFloat(mainForm.withdrawal || 0), 
                    note: mainForm.note
                }]);
                if (!error) { 
                    setMainForm({...mainForm, amount:'', deposit:'', withdrawal:'', note:'', date: getTaiwanDateTime() }); 
                    fetchData(); 
                }
            };

            const handleUpdate = async (id) => {
                const { error } = await supabase.from('records').update({
                    amount: parseFloat(editForm.amount), 
                    deposit: parseFloat(editForm.deposit || 0),
                    withdrawal: parseFloat(editForm.withdrawal || 0), 
                    date: new Date(editForm.date).toISOString(),
                    note: editForm.note 
                }).eq('id', id);
                if (!error) { setEditingId(null); fetchData(); }
            };

            const allData = useMemo(() => {
                let cumulativeFlow = 0;
                return records.map((r, i) => {
                    cumulativeFlow += (parseFloat(r.deposit || 0) - parseFloat(r.withdrawal || 0));
                    const prev = records[i-1];
                    const profit = prev ? (r.amount - prev.amount - (r.deposit || 0) + (r.withdrawal || 0)) : 0;
                    const roi = (prev && prev.amount !== 0) ? (profit / prev.amount) * 100 : 0;
                    const dateObj = new Date(r.date);
                    
                    let apy = 0;
                    if (prev) {
                        const prevDate = new Date(prev.date);
                        let daysDiff = (dateObj - prevDate) / (1000 * 60 * 60 * 24);
                        if (daysDiff < 0.1) daysDiff = 0.1;
                        const roiDecimal = roi / 100;
                        if (roiDecimal > -1) {
                            apy = (Math.pow(1 + roiDecimal, 365 / daysDiff) - 1) * 100;
                        }
                    }

                    return { 
                        ...r, ts: dateObj.getTime(),
                        displayDate: `${dateObj.getMonth() + 1}/${dateObj.getDate()}`,
                        displayDateTime: dateObj.toLocaleString([], {year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute:'2-digit'}),
                        '實際': r.amount, '還原': r.amount - cumulativeFlow, p: parseFloat(profit.toFixed(2)), r: roi, apy: apy
                    };
                });
            }, [records]);

            // 每日獲利彙總 (給日曆用)
            const dailyProfits = useMemo(() => {
                const map = {};
                allData.forEach(r => {
                    const d = new Date(r.date);
                    const y = d.getFullYear();
                    const m = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    const isoKey = `${y}-${m}-${day}`;

                    if (!map[isoKey]) map[isoKey] = 0;
                    map[isoKey] += r.p;
                });
                return map;
            }, [allData]);

            // 日曆邏輯
            const getDaysInMonth = (year, month) => new Date(year, month + 1, 0).getDate();
            const getFirstDayOfMonth = (year, month) => new Date(year, month, 1).getDay();

            const renderCalendar = () => {
                const year = calendarDate.getFullYear();
                const month = calendarDate.getMonth();
                const daysInMonth = getDaysInMonth(year, month);
                const firstDay = getFirstDayOfMonth(year, month);
                const days = [];

                for (let i = 0; i < firstDay; i++) {
                    days.push(<div key={`empty-${i}`} className="h-24 bg-gray-50/50 dark:bg-gray-900/30 border border-gray-100 dark:border-gray-800"></div>);
                }

                for (let i = 1; i <= daysInMonth; i++) {
                    const dayStr = String(i).padStart(2, '0');
                    const monthStr = String(month + 1).padStart(2, '0');
                    const dateKey = `${year}-${monthStr}-${dayStr}`;
                    const profit = dailyProfits[dateKey];

                    days.push(
                        <div key={dateKey} className="h-24 border border-gray-100 dark:border-gray-800 p-1 flex flex-col justify-between hover:bg-gray-50 dark:hover:bg-gray-900 transition-colors cursor-pointer" onClick={() => profit !== undefined && alert(`${dateKey}\n當日獲利: $${profit.toLocaleString()}`)}>
                            <span className="text-xs font-bold text-gray-400">{i}</span>
                            {profit !== undefined && (
                                <div className={`text-xs font-black truncate text-right ${profit >= 0 ? 'text-green-500' : 'text-red-500'}`}>
                                    {profit >= 0 ? '+' : ''}{Math.round(profit).toLocaleString()}
                                </div>
                            )}
                        </div>
                    );
                }
                return days;
            };

            // 分析資料篩選
            const analysisData = useMemo(() => {
                let filtered = allData;
                if (filterRange.start && filterRange.end) {
                    const sTs = new Date(filterRange.start).setHours(0,0,0,0);
                    const eTs = new Date(filterRange.end).setHours(23,59,59,999);
                    filtered = filtered.filter(r => r.ts >= sTs && r.ts <= eTs);
                }
                if (activeTag) {
                    filtered = filtered.filter(r => r.note && r.note.includes(activeTag));
                }
                return filtered;
            }, [allData, filterRange, activeTag]);

            const analysisStats = useMemo(() => {
                if (analysisData.length < 1) return { profit: 0, roi: 0, apy: 0, totalDep: 0, totalWith: 0 };
                const totalDep = analysisData.reduce((sum, r) => sum + parseFloat(r.deposit || 0), 0);
                const totalWith = analysisData.reduce((sum, r) => sum + parseFloat(r.withdrawal || 0), 0);
                const first = analysisData[0];
                const last = analysisData[analysisData.length - 1];
                const rangeProfit = last['還原'] - first['還原'];
                const rangeROI = (first['實際'] !== 0) ? (rangeProfit / first['實際']) * 100 : 0;
                let annualizedROI = 0;
                if (last.ts > first.ts) {
                    const daysDiff = (last.ts - first.ts) / (1000 * 60 * 60 * 24);
                    const effectiveDays = Math.max(daysDiff, 1);
                    const roiDecimal = rangeROI / 100;
                     if (roiDecimal > -1) {
                         annualizedROI = (Math.pow(1 + roiDecimal, 365 / effectiveDays) - 1) * 100;
                     }
                }
                return { profit: rangeProfit, roi: rangeROI, apy: annualizedROI, totalDep, totalWith };
            }, [analysisData]);

            const renderNoteWithTags = (note) => {
                if (!note) return null;
                const parts = note.split(/(#[^\s\u3000]+)/g); 
                return (
                    <span>
                        {parts.map((part, index) => {
                            if (part.startsWith('#') && part.length > 1) {
                                return (
                                    <span key={index} onClick={(e) => { e.stopPropagation()